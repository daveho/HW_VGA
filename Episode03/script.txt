Since we're going to describe design and operation of the Readout module
in some detail, let's take a page from CuriousMarc and enjoy some elevator
music.

The purpose of the Readout module is to generate the addresses of character
and attribute bytes so that the pixel generator can use them to generate
pixels and colors to send to the output module.

In order to understand the design of the Readout module, let's first discuss
the organization of video memory.

The display controller uses the VGA 640 by 480 mode to generate a text display
using a font with 8 by 16 characters. Dividing 640 by 8 and dividing 480 by 16
yields a text display with 80 columns and 30 rows of characters. Each displayed
character is represented by two bytes, one for the character and one for
the attribute byte containing the foreground and background colors. That means
that each row of characters requires 160 bytes of data. The total number of
bytes of memory needed for the display is 80 times 30 times 2, which is 4800.
This is why the VRAM module uses two 4KB dual port RAM chips rather than just 1:
with only one 4KB RAM chip, which can store only 4096 bytes of data,
there would not be enough room for all of the character and attribute information.

Each row of chararacters is displayed as 16 rows of pixels. The pixels are
rendered on the fly by fetching the appropriate bytes of character and attribute
information at the exact times they are needed by the pixel generator. This
means that the addresses of the bytes fetched for each of the 16 rows of pixels
in a character row are exactly the same each time. The only thing that
distinguishes the pixel rows in one character row from each other is the
low 4 bits of the vertical count, which selects the correct row of pixels
from the representation of the character glyph in the font ROM.

Now that we know how video memory is organized, we can appreciate the
essential function of the Readout module. It needs to be able to generate the
correct sequence of video memory addresses for each row of pixels.
It should start at address 0 in video memory for each pixel row in the first
row of characters. Each row of pixels in the first character row is rendered
by fetching the bytes at video memory addresses 0 through 159. After each
pixel row in the first character row has been displayed, the start address
for each pixel row in the second character row should start at address 160,
and each row is rendered by fetching the bytes at addresses 160 through 319.
The third character row requires fetching bytes starting at address 320,
and in general, the memory fetches for character row i start at address
160 Ã— i.

The Readout module employs a relatively simple strategy for generating the
video memory addresses for each pixel row. There are two registers, the
*row begin address register* and the *readout address register*. The row
begin address register, as the name suggests, keeps track of the address
where memory fetches should start for the current row of pixels. The readout
address register generates the address of the next data byte that needs to
fetched from video memory.

For every row of pixels in a character row other than the first one, before
starting to fetch memory for that row of pixels, the Readout module will
copy the address in the row begin address register to the readout address
register. This ensures that the last 15 pixel rows in a character row are
fetched from the correct range of video memory addresses.

Before rendering the first row of pixels in a character row, the current
value in the readout address register is copied to the row begin address
register. The idea here is that after fetching the memory address for
the final pixel row in the previous character row, the readout address
register will naturally contain the video memory address of the first
byte that should be fetched for the next character row. For example,
after fetching bytes 0 through 159 in order to render a row of pixels
for the first character row, the readout address register will contain
the value 160, which is the correct start address for fetching bytes
for the second character row.

The row begin register has two control signals. The clear signal, when
asserted, causes the value in the register to be set to 0. This happens
before rendering of a frame starts. The load signal, when asserted, causes
the contents of the readout address register to be copied into the
row begin address register. This means that the data outputs of the
readout address register are connected to the data inputs of the
row begin address register.

The readout address register has two control signals. The increment
signal, when asserted, causes the current value of the register to be
incremented by 1. For this reason, the readout address register is
implemented using binary counter chips. The load signal, when asserted,
causes the contents of the row begin address register to be copied into
the readout address register. This means that the outputs of the row begin
address register are connected to the inputs of the readout address
register.

The outputs of the readout address register are sent to the VRAM module,
so in general, the data outputs on the display controller side of the VRAM
module will reflect whatever data byte the Readout module wants to fetch.

The control signals for the row begin address register and readout address
register are generated by a GAL device. The inputs to the GAL are clock
and reset, the hsync pulse begin timing signal, and the horizontal activity
begin and end timing signals. We will talk about "activity" shortly, but for
now, all you need to know is that these signals allow the GAL to know
the precise horizontal timing it needs in order to fetch data bytes from
video memory at exactly the times that the pixel generator will need them.
The GAL takes a vertical activity signal from the Sync module, which
indicates whether or not the current scan line is one on which visible
pixels will be produced. The GAL uses the VSync signal from the Sync module
as a simple means to reset row begin address register before the beginning
of a frame. Finally, the GAL takes the low 4 bits of the vertical count
from the VCount module, which allows the GAL to know which pixel row in the
current character row is being rendered, which as we mentioned earlier,
determines the direction of data transfer between the row begin address
register and the readout address register.

Now let's return to the horizontal activity timing. As we mentioned, its
purpose is to make sure that data values are fetched from video memory at the
exact times that the pixel generator needs them. A horizontal scanline consists
of 800 clock cycles. The visible part of a scanline occurs bettween clocks
0 and 639. The horizontal sync pulse begins at clock 655, and ends at
clock 751. Horizontal activity --- meaning fetching data bytes from video
memory and rendering them as pixels --- must start before the beginning
of the scanline, in order that a block of 8 pixels and color information can
sent to the pixel generator at exactly clock 0 of the pixel row being
rendered. Horizontal activity thus begins at time 791, 9 clock cycles before
the first visible pixel in the next line is rendered. 9 cycles are needed
because each byte fetched from video memory requires 4 cycles, for a total
of 8 cycles, and because the control signals are registered outputs,
we need to initiate them one cycle early. Horizontal activity ends
at clock 633, just before the end of the visible part of the scanline.
At this point, all of the data for the scanline has been fetched,
and the readout address register has been incremented 160 times.

Now, let's consider how bytes of data are fetched from video memory.
The GAL implements a 3 bit binary counter which counts from 0 to 7,
then repeats. At counts 1 and 5, the readout address register is incremented.
These times are the beginning of the memory fetches for character data and
attribute data, respectively. Character data is fetched before attribute
data because it needs to be fed to the font ROM in order to select a row
of pixels from the correct glyph, which requires additional time.
At count 4, the fetched character data is clocked into a character
register, and at time 0, the fetched attribute data is clocked into an
attribute register. Because there are three clock cycles between the
address increment and clocking the data from video memory into a register,
and because clock cycles are about 39.7 ns, that means that the VRAM
module has about 119 ns to yield a byte of data, although incrementing
a counter is not instantaneous, and we need to meet the setup requirements
for the registers in which the data will be saved, so in reality we
need the data to appear within 100 ns or so. The IDT7314 chips I
am using have an access time of 70 ns, which should meet this requirement
comfortably.

This cadence --- increment, commit data to a register, increment, commit data
to a register --- continues until the horizontal activity period ends. As long
as we deliver the first character and attribute pair in a scanline at the correct
time, we are guaranteed to deliver all of the character/attribute pairs at the
correct time.

If you are thinking about this scheme carefully, you may have noticed a problem.
We increment the readout address at count 1, prior to committing the first byte
of character byte to a register. If the row begin register is reset to 0 before
the frame starts, this would suggest that the first character byte would be
fetched from address 1 rather than address 0. To avoid this problem, we actually
start horizontal activity at time 793 rather than 791, and start the count at
2 rather than 0. This effectively skips the first increment --- the one we
don't want --- and allows the first character to be fetched at address 0.

