The purpose of the Readout module is to generate the addresses of character
and attribute bytes so that the pixel generator can use them to generate
pixels and colors to send to the output module.

In order to understand the design of the Readout module, let's first discuss
the organization of video memory.

The display controller uses the VGA 640 by 480 mode to generate a text display
using a font with 8 by 16 characters. Dividing 640 by 8 and dividing 480 by 16
yields a text display with 80 columns and 30 rows of characters. Each displayed
character is represented by two bytes, one for the character and one for
the attribute byte containing the foreground and background colors. That means
that each row of characters requires 160 bytes of data. The total number of
bytes of memory needed for the display is 80 times 30 times 2, which is 4800.
This is why the VRAM module uses two 4KB dual port RAM chips rather than just 1:
with only one 4KB RAM chip, which can store only 4096 bytes of data,
there would not be enough room for all of the character and attribute information.

Each row of chararacters is displayed as 16 rows of pixels. The pixels are
rendered on the fly by fetching the appropriate bytes of character and attribute
information at the exact times they are needed by the pixel generator. This
means that the addresses of the bytes fetched for each of the 16 rows of pixels
in a character row are exactly the same each time. The only thing that
distinguishes the pixel rows in one character row from each other is the
low 4 bits of the vertical count, which selects the correct row of pixels
from the representation of the character glyph in the font ROM.

Now that we know how video memory is organized, we can appreciate the
essential function of the Readout module. It needs to be able to generate the
correct sequence of video memory addresses for each row of pixels.
It should start at address 0 in video memory for each pixel row in the first
row of characters. Each row of pixels in the first character row is rendered
by fetching the bytes at video memory addresses 0 through 159. After each
pixel row in the first character row has been displayed, the start address
for each pixel row in the second character row should start at address 160,
and each row is rendered by fetching the bytes at addresses 160 through 319.
The third character row requires fetching bytes starting at address 320,
and in general, the memory fetches for character row i start at address
160 Ã— i.

The Readout module employs a relatively simple strategy for generating the
video memory addresses for each pixel row. There are two registers, the
*row begin address register* and the *readout address register*. The row
begin address register, as the name suggests, keeps track of the address
where memory fetches should start for the current row of pixels. The readout
address register generates the address of the next data byte that needs to
fetched from video memory.

For every row of pixels in a character row other than the first one, before
starting to fetch memory for that row of pixels, the Readout module will
copy the address in the row begin address register to the readout address
register. This ensures that the last 15 pixel rows in a character row are
fetched from the correct range of video memory addresses.

Before rendering the first row of pixels in a character row, the current
value in the readout address register is copied to the row begin address
register. The idea here is that after fetching the memory address for
the final pixel row in the previous character row, the readout address
register will naturally contain the video memory address of the first
byte that should be fetched for the next character row. For example,
after fetching bytes 0 through 159 in order to render a row of pixels
for the first character row, the readout address register will contain
the value 160, which is the correct start address for fetching bytes
for the second character row.

The row begin register has two control signals. The clear signal, when
asserted, causes the value in the register to be set to 0. This happens
before rendering of a frame starts. The load signal, when asserted, causes
the contents of the readout address register to be copied into the
row begin address register. This means that the data outputs of the
readout address register are connected to the data inputs of the
row begin address register.

The readout address register has two control signals. The increment
signal, when asserted, causes the current value of the register to be
incremented by 1. For this reason, the readout address register is
implemented using binary counter chips. The load signal, when asserted,
causes the contents of the row begin address register to be copied into
the readout address register. This means that the outputs of the row begin
address register are connected to the inputs of the readout address
register.

The outputs of the readout address register are sent to the VRAM module,
so in general, the data outputs on the display controller side of the VRAM
module will reflect whatever data byte the Readout module wants to fetch.
