Before we go over the pixel generator hardware design, let's discuss how
it works.

You may recall from Episode 03 that the Readout module uses an 8-cycle
cadence to time the generation of data addresses to fetch from video memory.
At times 1 and 5, the Readout module increments the readout address
register, outputting the address of a byte to fetch from video memory.
At time 1, the generated address is for a character byte, and at time 5,
the generated address is for an attribute byte.

At time 4, the character byte fetched from VRAM is clocked into the character
register. The character data, along with the low 4 bits of the vertical count
and 4 bits selecting a font, is used to generate the address of a byte
from the font ROM. This byte contains a pattern of 8 pixels, which correspond
to one row of one displayed character.

At time 0, two important events occur. The pixel pattern fetched from the
font ROM is clocked into a shift register, and the attribute byte fetched
from video memory is clocked into a register. This gives the pixel generator
the data it needs to generate a block of 8 pixels to send to the Output
module. The font ROM stores the pixel patterns so that the most significant
bit of each pattern byte, bit 7, is the first pixel that should be sent to
the display, with 1 meaning a foreground color pixel and 0 meaning a
background color pixel. More generally, the shift register's bit 7 output
is the pixel generator's pixel output, and the bit output as bit 7 is the
pixel that is sent to the Output module.

At times 1 through 7, the data in the shift register is shifted one bit
to the left, meaning that bit 6 becomes bit 7, bit 5 becomes bit 6, and
so forth. By shifting the pixel data 7 times after the pattern byte is
loaded, all 8 bits of the pattern are sent to the Output module.
When the counter returns to time 0, another pattern byte and attribute byte
will be clocked into the shift register and attribute register, and the
process continues.

Now that we know the theory of operation, we can understand the pixel generator
module schematic.

The shift register is implemented as a GAL22V10 device. I originally was planning
to use a 74ACT166 shift register: however, this part does not seem to be common
and I was not able to find any for sale. This illustrates an important use case
for GAL devices. Not only can they implement arbitrary programmed logic, they can
also take the place of standard logic chips that either aren't available or
don't operate at the required speed. The GAL22V10 datasheet even mentions this
use case.

The character register and attribute registers are implemented using 74ACT574
parts.

The font ROM is an SST27SF512 flash memory chip. I chose this chip because I
have quite a few of them, they can be programmed by my T48 programmer, and they
have a 70 ns access time, which is sufficiently fast for the pattern data to be
ready at the time it needs to be clocked into the shift register.

The control signals for the shift register, character register, and attribute
register are generated by a GAL22V10. This control GAL uses the same timing signals
as the control GAL of the Readout module, and its state machine is very
similar.

Now that we've covered the pixel generator's theory of operation and schematic,
let's take a brief look at the simulation I used to gain confidence that the
design would work.
